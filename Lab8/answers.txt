1. We could replace the sequence number with a timestamp. The advantage to that approach would be that we don't have to store the current sequence number, and that it could let us sort temperatures from multiple picos. Right now, there's no way to tell if reading 20 from sensor A occurred before or after reading 30 from sensor B. It could also make it easier to tell if a sensor has failed (if we haven't had a message from it in a long time). The disadvantages would be that there wouldn't be a way to tell if you are missing messages from another sensor, because there will be variations in the increments between timestamps - one sensor may be sending every 30 seconds, another ever 60.

2. They're not in order, because I'm storing them as an unordered map. I think that's the best way to store internally, but you could provide a query to external users that returns them ordered, and just organize them and sort them by sensor and/or timestamp.

3. I avoided looping by having the peers send "seen" messages 50% of the time that updated the other pico about the messages I had seen (including theirs). Because I used an algorithm that prioritized sending seen messages to peers that had information I wanted, it sometimes resulted in delays in updating a pico that had just sent me a message, but overall it worked pretty well. The unique ID was helpful because it helped me keep track of what messages I had seen.

4. Pros for a high value of n include less bandwidth and processing used, and less storage used as the rumors accumulate. Cons include that if n isn't high enough compared to the frequency of sensor readings, the picos won't be able to keep each other caught up. For a low value of n, pros include lots of information exchange and it being more likely that all picos have all the temperatures at any one time. Cons include using lots of bandwidth and storage space to send messages.

5. Yes, new messages eventually ended up on all the connected nodes. They weren't displayed in the same order, mostly because I was using an unordered map. If I used an array, they would have also been in different orders because they arrived at different times to different picos.

6. It doesn't result in permanent gaps because once the node reconnects to the network, it starts broadcasting the information it does have, and the other nodes see that it's really behind and send all the messages it needs to catch up (how quickly depends on the algorithm... if it's only connected to 1 other node and that node has a lot of other messages to send and n is small, it will have a hard time catching up unless the other node's algorithm prioritizes "behind" nodes). 

7. You could add failure detection to the system by keeping a reachability table that contains all the nodes you know about, and a timestamp of when you last got a message from them (not the timestamp of the reading in the message). Whenever you get a new message, just update the timestamp. Then, you could have a scheduled event that checks the timestamps to see if any of them have "expired." Expired nodes are assumed to have failed, and another event is raised announcing the failure. Then you can do whatever you want with that: remove its subscription, try to query the node directly, etc.