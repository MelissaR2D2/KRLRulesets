1. I installed rules in the new child pico by having a rule that fired when the child pico was done being initialized. Then that rule installed one ruleset in the child pico that I wrote and called my "sensor_setup" ruleset. This ruleset had a series of rules in it that would install all the other rulesets the child pico needed. The first one would trigger upon the installation of the sensor_setup ruleset, and then each ruleset would be installed one after the other. Finally, a rule triggered after the last ruleset was installed that notified the parent the installation was complete. I did this to ensure there wouldn't be race conditions in the installations that would result in some rulesets failing to install because modules they depend on hadn't been installed yet.

2. My chain of rules described in my answer to question 1 ensured my picos were created and their rulesets installed before their profiles were updated. The parent only sends the profile update event after the child pico raise an event telling the parent that it is done installing all rulesets. 

3. I wrote a quick python script that used HTTP requests to test all the creating, updating, and deleting functionality. I used the jsonschema library to validate the JSON responses returned to make sure they conformed to what my tests expected. If a test fails, the script throws an error.

4. I actually had to programmatically create test channels in the sensor picos as part of the sensor creation process to allow my python script to send events to my picos to test the temperature readings were working, since the ECI returned during the creation process was specifically a parent-child one. I had a rule raise the wrangler:createChannel event and I had that channel sent back to the parent and stored along with the parent-child channel. If I needed to provide channels for peer-to-peer communication between the other sensor picos I would just have the parent send an event to the other picos notifying them of the new channel after it gets the test channel ECI from the child pico. The child picos would store their own map of the peer-to-peer connections they know about.